# Hot100

## 哈希

### [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/submissions/552565189/?envType=study-plan-v2&envId=top-100-liked)

* map维护已经遍历的数值和下标
* 判断遍历的当前数的值`nums[i]`满足 `taget-nums[i]`存在map中。
* 存在则返回 当前下标和map中满足条件的下标
* 不存在则加入到map中
* 都不满足  null

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target-nums[i])){
                return new int[] {i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
```

### [49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

* map
* map 维护每个字符串字典序排序后的字符串（K） 和对应组的集合List（V）

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
            HashMap<String, List<String>> map = new HashMap<>();
            for (int i = 0; i < strs.length; i++) {
                //字典序排序，
                char[] t = strs[i].toCharArray();
                Arrays.sort(t);
                //是否该组存在map中
                String k = String.valueOf(t);
                if (map.containsKey(k)){
                    //存在这样的组，加入这组对应的集合中
                    map.get(k).add(strs[i]);
                }else {
                    //不存在这样的组，自己成为一组，并加入到改组的集合
                    ArrayList<String> list = new ArrayList<>();
                    list.add(strs[i]);
                    map.put(k,list);
                }
            }

            //返回结果
            ArrayList<List<String>> res = new ArrayList<>();
            for (Map.Entry<String,List<String>> entry : map.entrySet()){
                res.add(entry.getValue());
            }
            return  res;
        }
}
```

### [128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/submissions/552612065/?envType=study-plan-v2&envId=top-100-liked)

* set去重
* 找到最长序列的起始位置 满足`nums[i] -1` 不在set中就是起始位置
* 从起始位置开始，遍历set直到不满足连续。

```java
class Solution {
      public int longestConsecutive(int[] nums) {

        //set去重
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        int max = 0;
        for (int num : nums) {
            //遍历数组nums[i] 是否满足nums[i]-1 在set中
            // *      若不在，该数字就是最长连续的起始位置 
            if (!set.contains(num-1)){
                // 若不在，该数字就是最长连续的起始位置 从起始位置开始，遍历set直到不满足连续。
                int t = num;
                int cnt = 1;
                while (set.contains(t + 1)){
                    t++;
                    cnt++;
                }
                 max = Math.max(max, cnt);
            }
        }
        return max;
    }
    }
```

## 双指针

### [283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

 * 题意：保持数组元素排序不变，将0元素移到最后并且不能复制数组
 * 思路
 *   双指针
 *   i 从前向后遍历
 *   j 从头开始，意义是非0元素可以插入的位置
 *   当 i指向非0元素时，nums[i]插入到j指向的位置 nums[j]的值保存在i指向的位置，并且j++
 *   这样经过一次循环，前面的数组都是按照原位置，并且0在最后的位置。

```java
class Solution {
        public void moveZeroes(int[] nums) {
        for(int i = 0 ,j = 0; i <nums.length; i++){
            if (nums[i] != 0){
                int t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
                j++;
            }
        }
    }
}
```

